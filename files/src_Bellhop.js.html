<!DOCTYPE html>
<html lang='en'>
<head>
	<title>Bellhop v1.2.0 API Documentation : src/Bellhop.js</title>
	<meta charset='utf-8'>
	<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
	<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>
	<link rel='shortcut icon' type='image/png' href='../assets/images/favicon.ico?v=1.2.0'>
	<link href='//fonts.googleapis.com/css?family=Titillium+Web:300,200,600' rel='stylesheet' type='text/css'>
	<link rel='stylesheet' type='text/css' href='../assets/css/libraries.css?v=1.2.0'>
	<link rel='stylesheet' type='text/css' href='../assets/css/main.css?v=1.2.0'>
</head>
<body>
<header>
	<nav class="navbar navbar-inverse navbar-fixed-top">
		<div class='container'>
			<div class="navbar-header">
				<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#docs-navbar">
					<span class="sr-only">Toggle navigation</span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
				</button>
				<a class="navbar-brand" href='https://github.com/CloudKidStudio/Bellhop'>
						<img src='../assets/images/logo.png?v=1.2.0' class="logo">
					<span class='project-name'>Bellhop</span>
					<span class="sr-only">API Documentation for:</span>
					<span class='version hidden-xs'>v1.2.0</span>
				</a>
			</div>
			<div class="collapse navbar-collapse" id="docs-navbar">
	      <ul class="scope-toggles text-center nav navbar-nav navbar-right">
					<li><input class='scope-toggle' 
						id='toggle-inherited' 
						type='checkbox' 
						data-toggle='toggle' 
						data-on='Inherited' 
						data-off='Inherited' 
						data-size='mini'
						data-width='80'>
					</li>
					<li><input class='scope-toggle' 
						id='toggle-protected' 
						type='checkbox' 
						data-toggle='toggle' 
						data-on='Protected' 
						data-off='Protected' 
						data-size='mini'
						data-width='80'>
					</li>
					<li><input class='scope-toggle' 
						id='toggle-private' 
						type='checkbox' 
						data-toggle='toggle' 
						data-on='Private' 
						data-off='Private' 
						data-size='mini'
						data-width='80'>
					</li>
					<li><input class='scope-toggle' 
						id='toggle-deprecated' 
						type='checkbox' 
						data-toggle='toggle' 
						data-on='Deprecated' 
						data-off='Deprecated' 
						data-size='mini'
						data-width='80'>
					</li>
				</ul>
			</div>
		</div>
	</nav>
</header>
<div class='container'>
<div class='row'>
<nav id='sidebar' class='col-sm-4 col-md-3'>
<h2>APIs</h2>
<div class='input-group'>
  <div class='input-group-addon'>
    <span class='glyphicon glyphicon-search'></span>
  </div>
  <input type='search' class='form-control' id='api-filter' placeholder='Type to filter APIs'>
  <span class='collapsed btn-close glyphicon glyphicon-remove-sign hidden'></span>
</div>
<nav class='navbar navbar-default'>
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="btn-group" role="group" aria-label="...">
    <button type="button" class="sidebar-toggle collapsed btn btn-default" id='toggle-classes' data-target='#classes-collapse'>
      Classes
      <span class='collapsed glyphicon glyphicon-chevron-up'></span>
      <span class='expanded glyphicon glyphicon-chevron-down'></span>
    </button>
    <button type="button" class="sidebar-toggle collapsed btn btn-default" id='toggle-modules' data-target='#modules-collapse'>
      Modules
      <span class='collapsed glyphicon glyphicon-chevron-up'></span>
      <span class='expanded glyphicon glyphicon-chevron-down'></span>
    </button>
  </div>

  <!-- Collect the nav links, forms, and other content for toggling -->
  <div class='collapse' id='classes-collapse'>
    <ul class='nav navbar-nav'>
        <li class='public'>
          <a href='../classes/Bellhop.html'>Bellhop</a>
        </li>
        <li class='public'>
          <a href='../classes/springroll.BellhopEventDispatcher.html'>springroll.BellhopEventDispatcher</a>
        </li>
    </ul>
  </div>

  <!-- Collect the nav links, forms, and other content for toggling -->
  <div class='collapse' id='modules-collapse'>
    <ul class='nav navbar-nav'>
    </ul>
  </div>
  <!-- /.container-fluid -->
</nav></nav>
<div class='col-sm-8 col-md-9'>
<div id='docs-main' class='apidocs'>
<h1 class="file-heading">File:Bellhop.js</h1>

<div class="file">
<pre class="code prettyprint linenums">(function(window, undefined)
{
	// Include event dispatcher
	var BellhopEventDispatcher = window.BellhopEventDispatcher;

	/**
	 *  Abstract the communication layer between the iframe
	 *  and the parent DOM
	 *  @class Bellhop
	 *  @extends BellhopEventDispatcher
	 */
	var Bellhop = function()
	{
		BellhopEventDispatcher.call(this);

		/**
		 *  Bound handler for the window message event
		 *  @property {Function} onReceive
		 *  @private
		 */
		this.onReceive = this.receive.bind(this);

		/**
		 *  If we are connected to another instance of the bellhop
		 *  @property {Boolean} connected
		 *  @readOnly
		 *  @default false
		 *  @private
		 */
		this.connected = false;

		/**
		 *  The name of this Bellhop instance, useful for debugging purposes
		 *  @param {String} name
		 */
		this.name = &#x27;&#x27;;

		/**
		 *  If this instance represents an iframe instance
		 *  @property {Boolean} isChild
		 *  @private
		 *  @default true
		 */
		this.isChild = true;

		/**
		 *  If we are current trying to connec
		 *  @property {Boolean} connecting
		 *  @default false
		 *  @private
		 */
		this.connecting = false;

		/**
		 *  If using cross-domain, the domain to post to
		 *  @property {Boolean} origin
		 *  @private
		 *  @default &quot;*&quot;
		 */
		this.origin = &quot;*&quot;;

		/**
		 *  Save any sends to wait until after we&#x27;re done
		 *  @property {Array} _sendLater
		 *  @private
		 */
		this._sendLater = [];

		/**
		 *  Do we have something to connect to, should be called after
		 *  attempting to &#x60;connect()&#x60;
		 *  @property {Boolean} supported
		 *  @readOnly
		 */
		this.supported = null;

		/**
		 * The iframe element
		 * @property {DOMElement} iframe
		 * @private
		 * @readOnly
		 */
		this.iframe = null;
	};

	// Reference to the prototype
	var s = BellhopEventDispatcher.prototype;
	var p = Bellhop.prototype = Object.create(s);

	/**
	 *  The connection has been established successfully
	 *  @event connected
	 */

	/**
	 *  Connection could not be established
	 *  @event failed
	 */

	/**
	 *  Handle messages in the window
	 *  @method receive
	 *  @private
	 */
	p.receive = function(event)
	{
		// Ignore events that don&#x27;t originate from the target
		// we&#x27;re connected to
		if (event.source !== this.target)
		{
			return;
		}

		var data = event.data;

		// This is the initial connection event
		if (data === &#x27;connected&#x27;)
		{
			this.connecting = false;
			this.connected = true;

			this.trigger(&#x27;connected&#x27;);

			// Be polite and respond to the child that we&#x27;re ready
			if (!this.isChild)
			{
				this.target.postMessage(data, this.origin);
			}

			var i, len = this._sendLater.length;

			// If we have any sends waiting to send
			// we are now connected and it should be okay 
			if (len &gt; 0)
			{
				for (i = 0; i &lt; len; i++)
				{
					var e = this._sendLater[i];
					this.send(e.type, e.data);
				}
				this._sendLater.length = 0;
			}
		}
		else
		{
			// Ignore all other event if we don&#x27;t have a context
			if (!this.connected) return;

			try
			{
				data = JSON.parse(data, Bellhop.reviver);
			}
			catch (err)
			{
				// If we can&#x27;t parse the JSON
				// just ignore it, this should
				// only be an object
				return;
			}

			// Only valid objects with a type and matching channel id
			if (typeof data === &quot;object&quot; &amp;&amp; data.type)
			{
				this.trigger(data);
			}
		}
	};

	/**
	 *  And override for the toString built-in method
	 *  @method toString
	 *  @return {String} Representation of this instance
	 */
	p.toString = function()
	{
		return &quot;[Bellhop &#x27;&quot; + this.name + &quot;&#x27;]&quot;;
	};

	/**
	 *  The target where to send messages
	 *  @property {DOM} target
	 *  @private
	 *  @readOnly
	 */
	Object.defineProperty(p, &quot;target&quot;,
	{
		get: function()
		{
			return this.isChild ? window.parent : this.iframe.contentWindow;
		}
	});

	/**
	 *  Setup the connection
	 *  @method connect
	 *  @param {DOM} [iframe] The iframe to communicate with. If no value is set, the assumption
	 *         is that we&#x27;re the child trying to communcate with our window.parent
	 *  @param {String} [origin=&quot;*&quot;] The domain to communicate with if different from the current.
	 *  @return {Bellhop} Return instance of current object
	 */
	p.connect = function(iframe, origin)
	{
		// Ignore if we&#x27;re already trying to connect
		if (this.connecting) return this;

		// Disconnect from any existing connection
		this.disconnect();

		// We are trying to connect
		this.connecting = true;

		//re-init if we had previously been destroyed
		if (!this._sendLater) this._sendLater = [];

		// The iframe if we&#x27;re the parent
		this.iframe = iframe || null;

		// The instance of bellhop is inside the iframe
		var isChild = this.isChild = (iframe === undefined);
		var target = this.target;
		this.supported = isChild ? !!target &amp;&amp; window != target : !!target;
		this.origin = origin === undefined ? &quot;*&quot; : origin;

		// Listen for incoming messages
		if (window.attachEvent)
		{
			window.attachEvent(&quot;onmessage&quot;, this.onReceive);
		}
		else
		{
			window.addEventListener(&quot;message&quot;, this.onReceive);
		}

		if (isChild)
		{
			// No parent, can&#x27;t connect
			if (window === target)
			{
				this.trigger(&#x27;failed&#x27;);
			}
			else
			{
				// If connect is called after the window is ready
				// we can go ahead and send the connect message
				if (window.document.readyState === &quot;complete&quot;)
				{
					target.postMessage(&#x27;connected&#x27;, this.origin);
				}
				else
				{
					// Or wait until the window is finished loading
					// then send the handshake to the parent
					window.onload = function()
					{
						target.postMessage(&#x27;connected&#x27;, this.origin);
					}.bind(this);
				}
			}
		}
		return this;
	};

	/**
	 *  Disconnect if there are any open connections
	 *  @method disconnect
	 */
	p.disconnect = function()
	{
		this.connected = false;
		this.connecting = false;
		this.origin = null;
		this.iframe = null;
		if (this._sendLater) this._sendLater.length = 0;
		this.isChild = true;

		if (window.detachEvent)
		{
			window.detachEvent(&quot;onmessage&quot;, this.onReceive);
		}
		else
		{
			window.removeEventListener(&quot;message&quot;, this.onReceive);
		}

		return this;
	};

	/**
	 *  Send an event to the connected instance
	 *  @method send
	 *  @param {String} event The event type to send to the parent
	 *  @param {Object} [data] Additional data to send along with event
	 *  @return {Bellhop} Return instance of current object
	 */
	p.send = function(event, data)
	{
		if (typeof event !== &quot;string&quot;)
		{
			throw &quot;The event type must be a string&quot;;
		}
		event = {
			type: event
		};

		// Add the additional data, if needed
		if (data !== undefined)
		{
			event.data = data;
		}
		if (this.connecting)
		{
			this._sendLater.push(event);
		}
		else if (!this.connected)
		{
			return this;
		}
		else
		{
			this.target.postMessage(JSON.stringify(event), this.origin);
		}
		return this;
	};

	/**
	 *  A convenience method for sending and the listening to create 
	 *  a singular link to fetching data. This is the same calling send
	 *  and then getting a response right away with the same event.
	 *  @method fetch
	 *  @param {String} event The name of the event
	 *  @param {Function} callback The callback to call after, takes event object as one argument
	 *  @param {Object} [data] Optional data to pass along
	 *  @param {Boolean} [runOnce=false] If we only want to fetch once and then remove the listener
	 *  @return {Bellhop} Return instance of current object
	 */
	p.fetch = function(event, callback, data, runOnce)
	{
		var self = this;

		if (!this.connecting &amp;&amp; !this.connected)
		{
			throw &quot;No connection, please call connect() first&quot;;
		}

		runOnce = runOnce === undefined ? false : runOnce;
		var internalCallback = function(e)
		{
			if (runOnce) self.off(e.type, internalCallback);
			callback(e);
		};
		this.on(event, internalCallback);
		this.send(event, data);
		return this;
	};

	/**
	 *  A convience method for listening to an event and then responding with some data
	 *  right away. Automatically removes the listener
	 *  @method respond
	 *  @param {String} event The name of the event
	 *  @param {Object} data The object to pass back. 
	 *  	May also be a function; the return value will be sent as data in this case.
	 *  @param {Boolean} [runOnce=false] If we only want to respond once and then remove the listener
	 *  @return {Bellhop} Return instance of current object
	 */
	p.respond = function(event, data, runOnce)
	{
		runOnce = runOnce === undefined ? false : runOnce;
		var self = this;
		var internalCallback = function(e)
		{
			if (runOnce) self.off(e.type, internalCallback);
			self.send(event, typeof data == &quot;function&quot; ? data() : data);
		};
		this.on(event, internalCallback);
		return this;
	};

	/**
	 *  Destroy and don&#x27;t user after this
	 *  @method destroy
	 */
	p.destroy = function()
	{
		s.destroy.call(this);
		this.disconnect();
		this._sendLater = null;
	};

	/**
	 * When restoring from JSON via &#x60;JSON.parse&#x60;, we may pass a reviver function.
	 * In our case, this will check if the object has a specially-named property (&#x60;__classname&#x60;).
	 * If it does, we will attempt to construct a new instance of that class, rather than using a
	 * plain old Object. Note that this recurses through the object.
	 * See &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse&quot;&gt;JSON.parse()&lt;/a&gt;
	 * @method  reviver
	 * @static
	 * @param  {String} key   each key name
	 * @param  {Object} value Object that we wish to restore
	 * @return {Object}       The object that was parsed - either cast to a class, or not
	 */
	Bellhop.reviver = function(key, value)
	{
		if (value &amp;&amp; typeof value.__classname == &quot;string&quot;)
		{
			var _class = include(value.__classname);
			if (_class)
			{
				var rtn = new _class();
				//if we may call fromJSON, do so
				if (rtn.fromJSON)
				{
					rtn.fromJSON(value);
					//return the cast Object
					return rtn;
				}
			}
		}
		//return the object we were passed in
		return value;
	};

	/**
	 * Simple return function
	 * @method include
	 * @private
	 * @param {string} classname Qualified class name as a string.
	 *        for example &quot;cloudkid.MyClass&quot; would return a reference
	 *        to the function window.cloudkid.MyClass.
	 */
	var include = function(classname)
	{
		var parts = classname.split(&#x27;.&#x27;);
		var parent = window;
		while (parts.length)
		{
			parent = parent[parts.shift()];
			if (!parent) return;
		}
		return parent;
	};

	// Assign to the global namespace
	window.Bellhop = Bellhop;

}(window));</pre>
</div></div>
</div>
</div>
</div>
<script src='../assets/js/libraries.js?v=1.2.0'></script>
<script src='../assets/js/main.js?v=1.2.0'></script>
</body>
</html>
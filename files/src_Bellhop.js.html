<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="https://yui-s.yahooapis.com/3.8.0/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.ico">
    <link href='//fonts.googleapis.com/css?family=Titillium+Web:300' rel='stylesheet' type='text/css'>
    <script src="https://yui-s.yahooapis.com/3.10.1/build/yui/yui-min.js"></script>
	<title>Bellhop v1.1.5 API Documentation : src/Bellhop.js</title>  
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><a href="https://github.com/CloudKidStudio/Bellhop"><img src="../assets/css/logo.png" title="Bellhop">Bellhop</a></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Documentation for: 1.1.5</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>
		<ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
			<li><a href="#api-modules">Modules</a></li>
        </ul>
        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Bellhop.html">Bellhop</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
            <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <script>
	var name = src/Bellhop.js      
</script>
<h1 class="file-heading">File:Bellhop.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
(function(window, undefined){

	/**
	*  Abstract the communication layer between the iframe
	*  and the parent DOM
	*  @class Bellhop
	*/
	var Bellhop = function()
	{
		/**
		*  Bound handler for the window message event
		*  @property {Function} onReceive
		*  @private
		*/
		this.onReceive = this.receive.bind(this);

		/**
		*  The target where to send messages
		*  @property {DOM} target
		*  @private
		*/
		this.target = null;

		/**
		*  If we are connected to another instance of the bellhop
		*  @property {Boolean} connected
		*  @readOnly
		*  @default false
		*  @private
		*/
		this.connected = false;

		/**
		*  The name of this Bellhop instance, useful for debugging purposes
		*  @param {String} name
		*/
		this.name = &#x27;&#x27;;

		/**
		*  If this instance represents an iframe instance
		*  @property {Boolean} isChild
		*  @private
		*  @default true
		*/
		this.isChild = true;

		/**
		*  If we are current trying to connec
		*  @property {Boolean} connecting
		*  @default false
		*  @private
		*/
		this.connecting = false;

		/**
		*  If using cross-domain, the domain to post to
		*  @property {Boolean} origin
		*  @private
		*  @default &quot;*&quot;
		*/
		this.origin = &quot;*&quot;;

		/**
		*  The collection of event listeners
		*  @property {Object} _listeners
		*  @private
		*/
		this._listeners = {};

		/**
		*  Save any sends to wait until after we&#x27;re done
		*  @property {Array} _sendLater
		*  @private
		*/
		this._sendLater = [];

		/**
		*  Do we have something to connect to, should be called after
		*  attempting to &#x60;connect()&#x60;
		*  @property {Boolean} supported
		*  @readOnly
		*/
		this.supported = null;
	};

	// Reference to the prototype
	var p = Bellhop.prototype = {};

	/**
	*  The connection has been established successfully
	*  @event connected
	*/

	/**
	*  Connection could not be established
	*  @event failed
	*/

	/**
	*  Handle messages in the window
	*  @method receive
	*  @private
	*/
	p.receive = function(event)
	{
		// Ignore events that don&#x27;t originate from the target
		// we&#x27;re connected to
		if (event.source !== this.target)
		{
			return;
		}

		var data = event.data;

		// This is the initial connection event
		if (data === &#x27;connected&#x27;)
		{
			this.connecting = false;
			this.connected = true;

			this.trigger(&#x27;connected&#x27;);

			// Be polite and respond to the child that we&#x27;re ready
			if (!this.isChild)
			{
				this.target.postMessage(data, this.origin);
			}

			var i, len = this._sendLater.length;

			// If we have any sends waiting to send
			// we are now connected and it should be okay 
			if (len &gt; 0)
			{
				for(i = 0; i &lt; len; i++)
				{
					var e = this._sendLater[i];
					this.send(e.type, e.data);
				}
				this._sendLater.length = 0;
			}
		}		
		else
		{
			// Ignore all other event if we don&#x27;t have a context
			if (!this.connected) return;

			try 
			{
				data = JSON.parse(data, Bellhop.reviver);
			}
			catch(err)
			{
				// If we can&#x27;t parse the JSON
				// just ignore it, this should
				// only be an object
				return;
			}

			// Only valid objects with a type and matching channel id
			if (typeof data === &quot;object&quot; &amp;&amp; data.type)
			{
				this.trigger(data);
			}			
		}
	};

	/**
	*  Trigger any event handlers for an event type
	*  @method trigger
	*  @private
	*  @param {Object} event The event to send
	*/
	p.trigger = function(event)
	{
		if (typeof event == &quot;string&quot;)
		{
			event = {type:event};
		}
		var listeners = this._listeners[event.type];
		if (listeners !== undefined)
		{
			for(var i = listeners.length - 1; i &gt;= 0; i--)
			{
				listeners[i](event);
			}
		}
	};

	/**
	*  And override for the toString built-in method
	*  @method toString
	*  @return {String} Representation of this instance
	*/
	p.toString = function()
	{
		return &quot;[Bellhop &#x27;&quot;+this.name+&quot;&#x27;]&quot;;
	};

	/**
	*  Setup the connection
	*  @method connect
	*  @param {DOM} [iframe] The iframe to communicate with. If no value is set, the assumption
	*         is that we&#x27;re the child trying to communcate with our window.top parent
	*  @param {String} [origin=&quot;*&quot;] The domain to communicate with if different from the current.
	*  @return {Bellhop} Return instance of current object
	*/
	p.connect = function(iframe, origin)
	{
		// Ignore if we&#x27;re already trying to connect
		if (this.connecting) return this;

		// Disconnect from any existing connection
		this.disconnect();

		// We are trying to connect
		this.connecting = true;

		// The instance of bellhop is inside the iframe
		var isChild = this.isChild = (iframe === undefined);
		var target = this.target = isChild ? window.top : (iframe.contentWindow || iframe);
		this.supported = isChild ? (!!target &amp;&amp; window != target) : !!target;
		this.origin = origin === undefined ? &quot;*&quot; : origin;

		// Listen for incoming messages
		if (window.attachEvent)
		{
			window.attachEvent(&quot;onmessage&quot;, this.onReceive);
		}
		else
		{
			window.addEventListener(&quot;message&quot;, this.onReceive);
		}

		if (isChild)
		{
			// No parent, can&#x27;t connect
			if (window === target)
			{
				this.trigger(&#x27;failed&#x27;);
			}
			else
			{
				// If connect is called after the window is ready
				// we can go ahead and send the connect message
				if (window.document.readyState === &quot;complete&quot;)
				{
					target.postMessage(&#x27;connected&#x27;, this.origin);
				}
				else
				{
					// Or wait until the window is finished loading
					// then send the handshake to the parent
					window.onload = function(){
						target.postMessage(&#x27;connected&#x27;, this.origin);
					}.bind(this);
				}
			}
		}
		return this;
	};

	/**
	*  Disconnect if there are any open connections
	*  @method disconnect
	*/
	p.disconnect = function()
	{
		this.connected = false;
		this.connecting = false;
		this.origin = null;
		this.target = null;
		this._listeners = {};
		this._sendLater.length = 0;
		this.isChild = true;

		if (window.detachEvent)
		{
			window.detachEvent(&quot;onmessage&quot;, this.onReceive);
		}
		else
		{
			window.removeEventListener(&quot;message&quot;, this.onReceive);
		}

		return this;
	};

	/**
	*  Add an event listener to the listen to an event from either the parent or iframe
	*  @method on
	*  @param {String|Object} type The type of event to listen for or a map of events to callbacks.
	*         Multiple events can be added by separating events with spaces.
	*  @param {Function} callback The handler when an event is triggered
	*  @param {int} [priority=0] The priority of the event listener. Higher numbers are handled first.
	*  @return {Bellhop} Return instance of current object
	*/
	p.on = function(type, callback, priority)
	{
		if (typeof type !== &quot;string&quot;)
		{
			for(var t in type)
			{
				this.on(t, type[t], priority);
			}
		}
		else
		{
			var types = type.split(&quot; &quot;);
			var listener;
			for(var i = 0, len = types.length; i &lt; len; i++)
			{
				type = types[i];

				listener = this._listeners[types];
				if(!listener)
					listener = this._listeners[types] = [];

				callback._priority = parseInt(priority) || 0;

				if (listener.indexOf(callback) === -1)
				{
					listener.push(callback);
					if(listener.length &gt; 1)
						listener.sort(listenerSorter);
				}
			}
		}
		return this;
	};

	/**
	*  Sorts listeners added by .on() by priority
	*/
	function listenerSorter(a, b)
	{
		return a._priority - b._priority;
	}

	/**
	*  Remove an event listener
	*  @method off
	*  @param {String} type The type of event to listen for. If undefined, remove all listeners.
	*  @param {Function} [callback] The optional handler when an event is triggered, if no callback
	*         is set then all listeners by type are removed
	*  @return {Bellhop} Return instance of current object
	*/
	p.off = function(type, callback)
	{
		if (type === undefined)
		{
			//remove all listeners
			this._listeners = {};
			return this;
		}
		if (this._listeners[type] === undefined)
		{
			return this;
		}
		if (callback === undefined)
		{
			delete this._listeners[type];
		}
		else
		{
			var listeners = this._listeners[type];
			for(var i = 0, len = listeners.length; i &lt; len; i++)
			{
				// Remove the listener
				if (listeners[i] === callback)
				{
					listeners.splice(i, 1);
					break;
				}
			}
		}
		return this;
	};

	/**
	*  Send an event to the connected instance
	*  @method send
	*  @param {String} event The event type to send to the parent
	*  @param {Object} [data] Additional data to send along with event
	*  @return {Bellhop} Return instance of current object
	*/
	p.send = function(event, data)
	{
		if (typeof event !== &quot;string&quot;)
		{
			throw &quot;The event type must be a string&quot;;
		}
		event = { type: event };

		// Add the additional data, if needed
		if (data !== undefined)
		{
			event.data = data;
		}
		if (this.connecting)
		{
			this._sendLater.push(event);
		}
		else if (!this.connected)
		{
			return this;
		}
		else
		{
			this.target.postMessage(JSON.stringify(event), this.origin);
		}
		return this;
	};

	/**
	*  A convenience method for sending and the listening to create 
	*  a singular link to fetching data. This is the same calling send
	*  and then getting a response right away with the same event.
	*  @method fetch
	*  @param {String} event The name of the event
	*  @param {Function} callback The callback to call after, takes event object as one argument
	*  @param {Object} [data] Optional data to pass along
	*  @param {Boolean} [runOnce=false] If we only want to fetch once and then remove the listener
	*  @return {Bellhop} Return instance of current object
	*/
	p.fetch = function(event, callback, data, runOnce)
	{
		var self = this;

		if (!this.connecting &amp;&amp; !this.connected)
		{
			throw &quot;No connection, please call connect() first&quot;;
		}
		
		runOnce = runOnce === undefined ? false : runOnce;
		var internalCallback = function(e)
		{
			if (runOnce) self.off(e.type, internalCallback);
			callback(e);
		};
		this.on(event, internalCallback);
		this.send(event, data);
		return this;
	};

	/**
	*  A convience method for listening to an event and then responding with some data
	*  right away. Automatically removes the listener
	*  @method respond
	*  @param {String} event The name of the event
	*  @param {Object} data The object to pass back. 
	*  	May also be a function; the return value will be sent as data in this case.
	*  @param {Boolean} [runOnce=false] If we only want to respond once and then remove the listener
	*  @return {Bellhop} Return instance of current object
	*/
	p.respond = function(event, data, runOnce)
	{
		runOnce = runOnce === undefined ? false : runOnce;
		var self = this;
		var internalCallback = function(e)
		{
			if (runOnce) self.off(e.type, internalCallback);
			self.send(event, typeof data == &quot;function&quot; ? data() : data);
		};
		this.on(event, internalCallback);
		return this;
	};

	/**
	*  Destroy and don&#x27;t user after this
	*  @method destroy
	*/
	p.destroy = function()
	{
		this.disconnect();
		this._listeners = null;
		this._sendLater = null;
	};

	/**
	 * When restoring from JSON via &#x60;JSON.parse&#x60;, we may pass a reviver function.
	 * In our case, this will check if the object has a specially-named property (&#x60;__classname&#x60;).
	 * If it does, we will attempt to construct a new instance of that class, rather than using a
	 * plain old Object. Note that this recurses through the object.
	 * See &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse&quot;&gt;JSON.parse()&lt;/a&gt;
	 * @method  reviver
	 * @static
	 * @param  {String} key   each key name
	 * @param  {Object} value Object that we wish to restore
	 * @return {Object}       The object that was parsed - either cast to a class, or not
	 */
	Bellhop.reviver = function(key, value)
	{
		if (value &amp;&amp; typeof value.__classname == &quot;string&quot;)
		{
			var _class = include(value.__classname);
			if(_class)
			{
				var rtn = new _class();
				//if we may call fromJSON, do so
				if(rtn.fromJSON)
				{
					rtn.fromJSON(value);
					//return the cast Object
					return rtn;
				}
			}
		}
		//return the object we were passed in
		return value;
	};

	/**
	 * Simple return function
	 * @method include
	 * @private
	 * @param {string} classname Qualified class name as a string.
	 *        for example &quot;cloudkid.MyClass&quot; would return a reference
	 *        to the function window.cloudkid.MyClass.
	 */
	var include = function(classname)
	{
		var parts = classname.split(&#x27;.&#x27;);
		var parent = window;
		while(parts.length)
		{
			parent = parent[parts.shift()];
			if (!parent) return;
		}
		return parent;
	};

	// Assign to the global namespace
	window.Bellhop = Bellhop;

}(window));

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
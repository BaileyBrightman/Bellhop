<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="https://yui-s.yahooapis.com/3.8.0/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.ico">
    <link href='http://fonts.googleapis.com/css?family=Titillium+Web:300' rel='stylesheet' type='text/css'>
    <script src="https://yui-s.yahooapis.com/3.10.1/build/yui/yui-min.js"></script>
	<title>Bellhop v1.0.4 API Documentation : src/Bellhop.js</title>  
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><a href="https://github.com/CloudKidStudio/Bellhop"><img src="../assets/css/logo.png" title="Bellhop">Bellhop</a></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Documentation for: 1.0.4</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>
		<ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
			<li><a href="#api-modules">Modules</a></li>
        </ul>
        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Bellhop.html">Bellhop</a></li>
            
                <li><a href="../classes/Function.prototype.bind.html">Function.prototype.bind</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/global.html">global</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
            <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <script>
	var name = src/Bellhop.js      
</script>
<h1 class="file-heading">File:Bellhop.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
(function(global, undefined){
	
	&quot;use strict&quot;;

	/**
	*  Abstract the communication layer between the iframe
	*  and the parent DOM
	*  @class Bellhop
	*  @constructor
	*  @param {String} [handshakeId=&quot;Bellhop&quot;] The Unique String dispatched to establish
	*         if we actually can use the frame, the parent DOM should send a message
	*         with the same exact string
	*/
	var Bellhop = function(handshakeId)
	{
		/**
		*  To establish an initial connection, the handshake id
		*  @property {String} handshakeId
		*  @private
		*  @default &quot;Bellhop&quot;
		*/
		this.handshakeId = handshakeId || &quot;Bellhop&quot;;

		/**
		*  Bound handler for the window message event
		*  @property {Function} onReceive
		*  @private
		*/
		this.onReceive = null;

		/**
		*  The target where to send messages
		*  @property {DOM} target
		*  @private
		*/
		this.target = null;

		/**
		*  If we are connected to another instance of the bellhop
		*  @property {Boolean} connected
		*  @readOnly
		*  @default false
		*  @private
		*/
		this.connected = false;

		/**
		*  The name of this Bellhop instance, useful for debugging purposes
		*  @param {String} name
		*/
		this.name = &#x27;&#x27;;

		/**
		*  If this instance represents an iframe instance
		*  @property {Boolean} isChild
		*  @private
		*  @default true
		*/
		this.isChild = true;

		/**
		*  If we are current trying to connec
		*  @property {Boolean} connecting
		*  @default false
		*  @private
		*/
		this.connecting = false;

		/**
		*  If using cross-domain, the domain to post to
		*  @property {Boolean} origin
		*  @private
		*  @default &quot;*&quot;
		*/
		this.origin = &quot;*&quot;;

		/**
		*  The collection of event listeners
		*  @property {Object} _listeners
		*  @private
		*/
		this._listeners = {};

		/**
		*  Save any sends to wait until after we&#x27;re done
		*  @property {Array} _sendLater
		*  @private
		*/
		this._sendLater = [];

		/**
		*  Do we have something to connect to, should be called after
		*  attempting to &#x60;connect()&#x60;
		*  @property {Boolean} supported
		*  @readOnly
		*/
		this.supported = null;
	};

	// Reference to the prototype
	var p = Bellhop.prototype = {};

	/**
	*  Fired when the connection has been established &quot;connected&quot;
	*  @property {String} CONNECTED
	*  @final
	*  @readOnly 
	*/
	Bellhop.CONNECTED = &quot;connected&quot;;

	/**
	*  Connection could not be established
	*  @property {String} FAILED
	*  @final
	*  @readOnly 
	*/
	Bellhop.FAILED = &quot;failed&quot;;

	/**
	*  Handle messages in the window
	*  @method receive
	*  @private
	*/
	p.receive = function(event)
	{
		var data = event.data;
		var i, len;

		// This is the initial connection event
		if (data == this.handshakeId)
		{
			this.connecting = false;
			this.connected = true;

			this.trigger(Bellhop.CONNECTED);

			// Be polite and respond to the child that we&#x27;re ready
			if (!this.isChild)
			{
				this.target.postMessage(data, this.origin);
			}

			len = this._sendLater.length;

			// If we have any sends waiting to send
			// we are now connected and it should be okay 
			if (len &gt; 0)
			{
				for(i = 0; i &lt; len; i++)
				{
					var e = this._sendLater[i];
					this.send(e.type, e.data);
				}
				this._sendLater.length = 0;
			}
		}		
		else
		{
			// Ignore all other event if we don&#x27;t have a context
			if (!this.connected) return;

			data = JSON.parse(data);
			// Check for event object
			if (typeof data !== &quot;object&quot;)
			{
				throw &quot;The event received must be an object&quot;;
			}

			// Check for type
			if (!data.type)
			{
				throw &quot;The event received must contain a type&quot;;
			}
			this.trigger(data);
		}
	};

	/**
	*  Trigger any event handlers for an event type
	*  @method trigger
	*  @private
	*  @param {Object} event The event to send
	*/
	p.trigger = function(event)
	{
		if (typeof event == &quot;string&quot;)
		{
			event = {type:event};
		}
		var listeners = this._listeners[event.type];
		if (listeners !== undefined)
		{
			for(var i = 0, len = listeners.length; i &lt; len; i++)
			{
				listeners[i](event);
			}
		}
	};

	/**
	*  And override for the toString built-in method
	*  @method toString
	*  @return {String} Representation of this instance
	*/
	p.toString = function()
	{
		return &quot;[Bellhop &#x27;&quot;+this.name+&quot;&#x27;]&quot;;
	};

	/**
	*  Setup the connection
	*  @method connect
	*  @param {DOM} [iframe] The iframe to communicate with. If no value is set, the assumption
	*         is that we&#x27;re the child trying to communcate with our window.top parent
	*  @param {String} [origin=&quot;*&quot;] The domain to communicate with if different from the current.
	*  @return {Bellhop} Return instance of current object
	*/
	p.connect = function(iframe, origin)
	{
		// Ignore if we&#x27;re already trying to connect
		if (this.connecting) return this;

		// We are trying to connect
		this.connecting = true;

		// The instance of bellhop is inside the iframe
		var isChild = this.isChild = (iframe === undefined);
		var target = this.target = isChild ? global.top : (iframe.contentWindow || iframe);
		this.supported = isChild ? (!!target &amp;&amp; global != target) : !!target;
		this.origin = origin === undefined ? &quot;*&quot; : origin;

		// Bound receive function to destroy later
		this.onReceive = this.receive.bind(this);

		// Listen for incoming messages
		if (global.attachEvent)
		{
			global.attachEvent(&quot;onmessage&quot;, this.onReceive);
		}
		else
		{
			global.addEventListener(&quot;message&quot;, this.onReceive);
		}

		if (isChild)
		{
			// No parent, can&#x27;t connect
			if (window === target)
			{
				//this.trigger(Bellhop.FAILED);
				this.connecting = false;
				this.connected = false;	
			}
			else
			{
				// Wait until the window is finished loading
				// then send the handshake to the parent
				var self = this;
				global.onload = function()
				{
					target.postMessage(self.handshakeId, self.origin);	
				};
			}
		}
		return this;
	};

	/**
	*  Disconnect if there are any open connections
	*  @method disconnect
	*/
	p.disconnect = function()
	{
		this.connected = false;
		this.connecting = false;
		this.origin = null;
		this.target = null;
		this._listeners = {};
		this._sendLater.length = 0;
		this.isChild = true;

		if (global.detachEvent)
		{
			global.detachEvent(&quot;onmessage&quot;, this.onReceive);
		}
		else
		{
			global.removeEventListener(&quot;message&quot;, this.onReceive);
		}
		
		this.onReceive = null;

		return this;
	};

	/**
	*  Add an event listener to the listen to an event from either the parent or iframe
	*  @method on
	*  @param {String|Object} type The type of event to listen for or a map of events to callbacks.
	*         Multiple events can be added by separating events with spaces.
	*  @param {Function} callback The handler when an event is triggered
	*  @return {Bellhop} Return instance of current object
	*/
	p.on = function(type, callback)
	{
		if (typeof type !== &quot;string&quot;)
		{
			for(var t in type)
			{
				this.on(t, type[t]);
			}
		}
		else
		{
			var types = type.split(&quot; &quot;);

			for(var i = 0, len = types.length; i &lt; len; i++)
			{
				type = types[i];

				if (this._listeners[type] === undefined)
				{
					this._listeners[type] = [];
				}
				this._listeners[type].push(callback);
			}
		}
		return this;
	};

	/**
	*  Remove an event listener
	*  @method off
	*  @param {String} type The type of event to listen for
	*  @param {Function} [callback] The optional handler when an event is triggered, if no callback
	*         is set then all listeners by type are removed
	*  @return {Bellhop} Return instance of current object
	*/
	p.off = function(type, callback)
	{
		if (this._listeners[type] === undefined)
		{
			return this;
		}
		if (callback === undefined)
		{
			delete this._listeners[type];
		}
		else
		{
			var listeners = this._listeners[type];
			for(var i = 0, len = listeners.length; i &lt; len; i++)
			{
				// Remove the listener
				if (listeners[i] === callback)
				{
					listeners.splice(i, 1);
					break;
				}
			}
		}
		return this;
	};

	/**
	*  Send an event to the connected instance
	*  @method send
	*  @param {String} event The event type to send to the parent
	*  @param {Object} [data] Additional data to send along with event
	*  @return {Bellhop} Return instance of current object
	*/
	p.send = function(event, data)
	{
		if (typeof event !== &quot;string&quot;)
		{
			throw &quot;The event type must be a string&quot;;
		}
		event = {type:event};

		// Add the additional data, if needed
		if (data !== undefined)
		{
			event.data = data;
		}
		if (this.connecting)
		{
			this._sendLater.push(event);
		}
		else if (!this.connected)
		{
			return this;
		}
		else
		{
			this.target.postMessage(JSON.stringify(event), this.origin);
		}
		return this;
	};

	/**
	*  A convenience method for sending and the listening to create 
	*  a singular link to fetching data. This is the same calling send
	*  and then getting a response right away with the same event.
	*  @method fetch
	*  @param {String} event The name of the event
	*  @param {Function} callback The callback to call after, takes event object as one argument
	*  @param {Object} [data] Optional data to pass along
	*  @param {Boolean} [runOnce=false] If we only want to fetch once and then remove the listener
	*  @return {Bellhop} Return instance of current object
	*/
	p.fetch = function(event, callback, data, runOnce)
	{
		var self = this;

		if (!this.connecting &amp;&amp; !this.connected)
		{
			throw &quot;No connection, please call connect() first&quot;;
		}
		
		runOnce = runOnce === undefined ? false : runOnce;
		var internalCallback = function(e)
		{
			if (runOnce) self.off(e.type, internalCallback);
			callback(e);
		};
		this.on(event, internalCallback);
		this.send(event, data);
		return this;
	};

	/**
	*  A convience method for listening to an event and then responding with some data
	*  right away. Automatically removes the listener
	*  @method respond
	*  @param {String} event The name of the event
	*  @param {Object} data The object to pass back
	*  @param {Boolean} [runOnce=false] If we only want to respond once and then remove the listener
	*  @return {Bellhop} Return instance of current object
	*/
	p.respond = function(event, data, runOnce)
	{
		runOnce = runOnce === undefined ? false : runOnce;
		var self = this;
		var internalCallback = function(e)
		{
			if (runOnce) self.off(e.type, internalCallback);
			self.send(event, data);
		};
		this.on(event, internalCallback);
		return this;
	};

	/**
	*  Destroy and don&#x27;t user after this
	*  @method destroy
	*/
	p.destroy = function()
	{
		this.disconnect();
		this._listeners = null;
		this._sendLater = null;
	};

	// Assign to the global namespace
	global.Bellhop = Bellhop;

}(window));

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
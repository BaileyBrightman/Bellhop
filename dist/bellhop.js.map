{"version":3,"file":"bellhop.js","sources":["../src/BellhopEventDispatcher.js","../src/Bellhop.js"],"sourcesContent":["/**\n * Function with a added priority type\n * @typedef {Function} PriorityFunction\n * @property {number} _priority\n */\n\n/**\n * Generic event dispatcher\n * @class  BellhopEventDispatcher\n */\nexport class BellhopEventDispatcher {\n  /**\n   *  The collection of event listeners\n   *  @property {Object} _listeners\n   *  @private\n   */\n  constructor() {\n    this._listeners = {};\n  }\n\n  /**\n   *  Add an event listener to the listen to an event from either the parent or iframe\n   *  @method on\n   *  @param {String} name The name of the event to listen\n   *  @param {PriorityFunction} callback The handler when an event is triggered\n   *  @param {number} [priority=0] The priority of the event listener. Higher numbers are handled first.\n   */\n  on(name, callback, priority = 0) {\n    if (!this._listeners[name]) {\n      this._listeners[name] = [];\n    }\n    callback._priority = parseInt(priority) || 0;\n\n    // If callback is already set to this event\n    if (-1 !== this._listeners[name].indexOf(callback)) {\n      return;\n    }\n\n    this._listeners[name].push(callback);\n\n    if (this._listeners[name].length > 1) {\n      this._listeners[name].sort(this.listenerSorter);\n    }\n  }\n\n  /**\n   * @private\n   * @param {PriorityFunction} a\n   * @param {PriorityFunction} b\n   * @returns {number};\n   *  Sorts listeners added by .on() by priority\n   */\n  listenerSorter(a, b) {\n    return a._priority - b._priority;\n  }\n\n  /**\n   *  Remove an event listener\n   *  @method off\n   *  @param {String} name The name of event to listen for. If undefined, remove all listeners.\n   *  @param {Function} [callback] The optional handler when an event is triggered, if no callback\n   *         is set then all listeners by type are removed\n   */\n  off(name, callback) {\n    if (this._listeners[name] === undefined) {\n      return;\n    }\n\n    if (callback === undefined) {\n      delete this._listeners[name];\n      return;\n    }\n\n    const index = this._listeners[name].indexOf(callback);\n\n    -1 < index ? this._listeners[name].splice(index, 1) : undefined;\n  }\n\n  /**\n   *  Trigger any event handlers for an event type\n   *  @method trigger\n   *  @param {object | String} event The event to send\n   *  @param {object} [data = {}] optional data to send to other areas in the app that are listening for this event\n   */\n  trigger(event, data = {}) {\n    if (typeof event == 'string') {\n      event = {\n        type: event,\n        data: 'object' === typeof data && null !== data ? data : {}\n      };\n    }\n\n    if ('undefined' !== typeof this._listeners[event.type]) {\n      for (let i = this._listeners[event.type].length - 1; i >= 0; i--) {\n        this._listeners[event.type][i](event);\n      }\n    }\n  }\n\n  /**\n   * Reset the listeners object\n   * @method  destroy\n   */\n  destroy() {\n    this._listeners = {};\n  }\n}\n","import { BellhopEventDispatcher } from './BellhopEventDispatcher.js';\n\n/**\n *  Abstract the communication layer between the iframe\n *  and the parent DOM\n *  @class Bellhop\n *  @extends BellhopEventDispatcher\n */\nexport class Bellhop extends BellhopEventDispatcher {\n  /**\n   * Creates an instance of Bellhop.\n   * @memberof Bellhop\n   * @param { string | number } id the id of the Bellhop instance\n   */\n  constructor(id = (Math.random() * 100) | 0) {\n    super();\n\n    /**\n     *  The instance ID for bellhop\n     *  @property {string} id\n     */\n    this.id = `BELLHOP:${id}`;\n    /**\n     *  If we are connected to another instance of the bellhop\n     *  @property {Boolean} connected\n     *  @readOnly\n     *  @default false\n     *  @private\n     */\n    this.connected = false;\n\n    /**\n     *  If this instance represents an iframe instance\n     *  @property {Boolean} isChild\n     *  @private\n     *  @default true\n     */\n    this.isChild = true;\n\n    /**\n     *  If we are current trying to connec\n     *  @property {Boolean} connecting\n     *  @default false\n     *  @private\n     */\n    this.connecting = false;\n\n    /**\n     *  If using cross-domain, the domain to post to\n     *  @property {string} origin\n     *  @private\n     *  @default \"*\"\n     */\n    this.origin = '*';\n\n    /**\n     *  Save any sends to wait until after we're done\n     *  @property {Array} _sendLater\n     *  @private\n     */\n    this._sendLater = [];\n\n    /**\n     * The iframe element\n     * @property {HTMLIFrameElement} iframe\n     * @private\n     * @readOnly\n     */\n    this.iframe = null;\n\n    /**\n     * The bound receive function\n     * @property {Function} receive\n     * @private\n     */\n    this.receive = this.receive.bind(this);\n  }\n\n  /**\n   *  The connection has been established successfully\n   *  @event connected\n   */\n\n  /**\n   *  Connection could not be established\n   *  @event failed\n   */\n\n  /**\n   *  Handle messages in the window\n   *  @method receive\n   *  @param { MessageEvent } message the post message received from another bellhop instance\n   *  @private\n   */\n  receive(message) {\n    // Ignore messages that don't originate from the target\n    // we're connected to\n    if (this.target !== message.source) {\n      return;\n    }\n\n    // If this is not the initial connection message\n    if (message.data !== 'connected') {\n      let data = message.data;\n      // Check to see if the data was sent as a stringified json\n      if ('string' === typeof data) {\n        try {\n          data = JSON.parse(data);\n        } catch (err) {\n          console.error('Bellhop error: ', err);\n        }\n      }\n      if (this.connected && 'object' === typeof data && data.type) {\n        this.trigger(data);\n      }\n      return;\n    }\n    // Else setup the connection\n    this.onConnectionReceived(message.data);\n  }\n  /**\n   * @memberof Bellhop\n   * @param {object} message the message received from the other bellhop instance\n   * @private\n   */\n  onConnectionReceived(message) {\n    this.connecting = false;\n    this.connected = true;\n\n    // Be polite and respond to the child that we're ready\n    if (!this.isChild) {\n      this.target.postMessage(message, this.origin);\n    }\n\n    // If we have any sends waiting to send\n    // we are now connected and it should be okay\n    for (let i = 0; i < this._sendLater.length; i++) {\n      const { type, data } = this._sendLater[i];\n      this.send(type, data);\n    }\n    this._sendLater.length = 0;\n\n    // If there is a connection event assigned call it\n    this.trigger('connected');\n  }\n\n  /**\n   *  Setup the connection\n   *  @method connect\n   *  @param {HTMLIFrameElement} iframe The iframe to communicate with. If no value is set, the assumption\n   *         is that we're the child trying to communcate with our window.parent\n   *  @param {String} [origin=\"*\"] The domain to communicate with if different from the current.\n   *  @return {Bellhop} Return instance of current object\n   */\n  connect(iframe, origin = '*') {\n    // Ignore if we're already trying to connect\n    if (this.connecting) {\n      return;\n    }\n\n    // Disconnect from any existing connection\n    this.disconnect();\n\n    // We are trying to connect\n    this.connecting = true;\n\n    // The iframe if we're the parent\n    if (iframe instanceof HTMLIFrameElement) {\n      this.iframe = iframe;\n    }\n\n    // The instance of bellhop is inside the iframe\n    this.isChild = iframe === undefined;\n\n    this.supported = true;\n    if (this.isChild) {\n      // for child pages, the window passed must be a different window\n      this.supported = window != iframe;\n    }\n\n    this.origin = origin;\n\n    window.addEventListener('message', this.receive);\n\n    if (this.isChild) {\n      // No parent, can't connect\n      if (window === this.target) {\n        this.trigger('failed');\n      } else {\n        // If connect is called after the window is ready\n        // we can go ahead and send the connect message\n        this.target.postMessage('connected', this.origin);\n      }\n    }\n  }\n\n  /**\n   *  Disconnect if there are any open connections\n   *  @method disconnect\n   */\n  disconnect() {\n    this.connected = false;\n    this.connecting = false;\n    this.origin = null;\n    this.iframe = null;\n    this.isChild = true;\n    this._sendLater.length = 0;\n\n    window.removeEventListener('message', this.receive);\n  }\n\n  /**\n   *  Send an event to the connected instance\n   *  @method send\n   *  @param {string} type name/type of the event\n   *  @param {*} [data = {}] Additional data to send along with event\n   */\n  send(type, data = {}) {\n    if (typeof type !== 'string') {\n      throw 'The event type must be a string';\n    }\n\n    const message = {\n      type,\n      data\n    };\n\n    if (this.connecting) {\n      this._sendLater.push(message);\n    } else {\n      this.target.postMessage(JSON.stringify(message), this.origin);\n    }\n  }\n\n  /**\n   *  A convenience method for sending and the listening to create\n   *  a singular link to fetching data. This is the same calling send\n   *  and then getting a response right away with the same event.\n   *  @method fetch\n   *  @param {String} event The name of the event\n   *  @param {Function} callback The callback to call after, takes event object as one argument\n   *  @param {Object} [data = {}] Optional data to pass along\n   *  @param {Boolean} [runOnce=false] If we only want to fetch once and then remove the listener\n   */\n  fetch(event, callback, data = {}, runOnce = false) {\n    if (!this.connecting && !this.connected) {\n      throw 'No connection, please call connect() first';\n    }\n\n    const internalCallback = e => {\n      if (runOnce) {\n        this.off(e.type, internalCallback);\n      }\n\n      callback(e);\n    };\n\n    this.on(event, internalCallback);\n    this.send(event, data);\n  }\n\n  /**\n   *  A convience method for listening to an event and then responding with some data\n   *  right away. Automatically removes the listener\n   *  @method respond\n   *  @param {String} event The name of the event\n   *  @param {Object | function} [data = {}] The object to pass back.\n   *  \tMay also be a function; the return value will be sent as data in this case.\n   *  @param {Boolean} [runOnce=false] If we only want to respond once and then remove the listener\n   */\n  async respond(event, data = {}, runOnce = false) {\n    const internalCallback = async function(e){\n      if (runOnce) {\n        this.off(e.type, internalCallback);\n      }\n      /*console.log(data);\n     \n      if(typeof data === 'function'){\n        data = data(); \n      }\n    \n      data = await data; */\n      \n      this.send(event, data);\n    };\n    this.on(event, internalCallback);\n  }\n\n  /**\n   *  Destroy and don't user after this\n   *  @method destroy\n   */\n  destroy() {\n    super.destroy();\n    this.disconnect();\n    this._sendLater.length = 0;\n  }\n\n  /**\n   *\n   * Returns the correct parent element for Bellhop's context\n   * @readonly\n   * @memberof Bellhop\n   */\n  get target() {\n    return this.isChild ? window.parent : this.iframe.contentWindow;\n  }\n}\n"],"names":["BellhopEventDispatcher","_listeners","name","callback","priority","this","_priority","parseInt","indexOf","push","length","sort","listenerSorter","a","b","undefined","index","splice","event","data","type","i","Bellhop","id","Math","random","connected","isChild","connecting","origin","_sendLater","iframe","receive","_this","bind","message","target","source","onConnectionReceived","JSON","parse","err","error","trigger","postMessage","send","disconnect","HTMLIFrameElement","supported","window","addEventListener","removeEventListener","stringify","runOnce","on","internalCallback","off","e","parent","contentWindow"],"mappings":"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"}
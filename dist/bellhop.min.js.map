{"version":3,"file":"bellhop.min.js","sources":["../src/BellhopEventDispatcher.js","../src/Bellhop.js"],"sourcesContent":["/**\n * Generic event dispatcher\n * @class  BellhopEventDispatcher\n */\nexport default class BellhopEventDispatcher {\n  /**\n   *  The collection of event listeners\n   *  @property {Object} _listeners\n   *  @private\n   */\n  constructor() {\n    this._listeners = {};\n  }\n\n  /**\n   *  Add an event listener to the listen to an event from either the parent or iframe\n   *  @method on\n   *  @param {String|Object} type The type of event to listen for or a map of events to callbacks.\n   *         Multiple events can be added by separating events with spaces.\n   *  @param {Function} callback The handler when an event is triggered\n   *  @param {number} [priority=0] The priority of the event listener. Higher numbers are handled first.\n   *  @return {this} Return instance of current object\n   */\n  on(type, callback, priority) {\n    if (typeof type !== 'string') {\n      for (let t in type) {\n        this.on(t, type[t], priority);\n      }\n    } else {\n      let types = type.split(' ');\n      let listener;\n      for (let i = 0, len = types.length; i < len; i++) {\n        type = types[i];\n\n        listener = this._listeners[type];\n        if (!listener) {\n          listener = this._listeners[type] = [];\n        }\n\n        callback._priority = parseInt(priority) || 0;\n\n        if (listener.indexOf(callback) === -1) {\n          listener.push(callback);\n          if (listener.length > 1) {\n            listener.sort(this.listenerSorter);\n          }\n        }\n      }\n    }\n    return this;\n  }\n\n  /**\n   *  Sorts listeners added by .on() by priority\n   */\n  listenerSorter(a, b) {\n    return a._priority - b._priority;\n  }\n\n  /**\n   *  Remove an event listener\n   *  @method off\n   *  @param {String} type The type of event to listen for. If undefined, remove all listeners.\n   *  @param {Function} [callback] The optional handler when an event is triggered, if no callback\n   *         is set then all listeners by type are removed\n   *  @return {this} Return instance of current object\n   */\n  off(type, callback) {\n    if (type === undefined || !this._listeners) {\n      //remove all listeners\n      this._listeners = {};\n      return this;\n    }\n    if (this._listeners[type] === undefined) {\n      return this;\n    }\n    if (callback === undefined) {\n      delete this._listeners[type];\n    } else {\n      let listeners = this._listeners[type];\n      for (let i = 0, len = listeners.length; i < len; i++) {\n        // Remove the listener\n        if (listeners[i] === callback) {\n          listeners.splice(i, 1);\n          break;\n        }\n      }\n    }\n    return this;\n  }\n\n  /**\n   *  Trigger any event handlers for an event type\n   *  @method trigger\n   *  @param {Object} event The event to send\n   */\n  trigger(event) {\n    if (typeof event == 'string') {\n      event = {\n        type: event\n      };\n    }\n    let listeners = this._listeners[event.type];\n    if (listeners !== undefined) {\n      for (let i = listeners.length - 1; i >= 0; i--) {\n        listeners[i](event);\n      }\n    }\n  }\n\n  /**\n   * Destroy this object\n   * @method  destroy\n   */\n  destroy() {\n    this._listeners = null;\n  }\n}\n","import BellhopEventDispatcher from './BellhopEventDispatcher.js';\n/**\n *  Abstract the communication layer between the iframe\n *  and the parent DOM\n *  @class Bellhop\n *  @extends BellhopEventDispatcher\n */\nexport default class Bellhop extends BellhopEventDispatcher {\n  /**\n   * Creates an instance of Bellhop.\n   * @memberof Bellhop\n   */\n  constructor() {\n    super();\n\n    /**\n     *  If we are connected to another instance of the bellhop\n     *  @property {Boolean} connected\n     *  @readOnly\n     *  @default false\n     *  @private\n     */\n    this.connected = false;\n\n    /**\n     *  The name of this Bellhop instance, useful for debugging purposes\n     *  @param {String} name\n     */\n    this.name = '';\n\n    /**\n     *  If this instance represents an iframe instance\n     *  @property {Boolean} isChild\n     *  @private\n     *  @default true\n     */\n    this.isChild = true;\n\n    /**\n     *  If we are current trying to connec\n     *  @property {Boolean} connecting\n     *  @default false\n     *  @private\n     */\n    this.connecting = false;\n\n    /**\n     *  If using cross-domain, the domain to post to\n     *  @property {Boolean} origin\n     *  @private\n     *  @default \"*\"\n     */\n    this.origin = '*';\n\n    /**\n     *  Save any sends to wait until after we're done\n     *  @property {Array} _sendLater\n     *  @private\n     */\n    this._sendLater = [];\n\n    /**\n     *  Do we have something to connect to, should be called after\n     *  attempting to `connect()`\n     *  @property {Boolean} supported\n     *  @readOnly\n     */\n    this.supported = null;\n\n    /**\n     * The iframe element\n     * @property {DOMElement} iframe\n     * @private\n     * @readOnly\n     */\n    this.iframe = null;\n\n    this.target = this.isChild ? window.parent : this.iframe.contentWindow;\n  }\n\n  /**\n   *  The connection has been established successfully\n   *  @event connected\n   */\n\n  /**\n   *  Connection could not be established\n   *  @event failed\n   */\n\n  /**\n   *  Handle messages in the window\n   *  @method receive\n   *  @private\n   */\n  receive(event) {\n    // Ignore events that don't originate from the target\n    // we're connected to\n    if (event.source !== this.target) {\n      return;\n    }\n\n    const data = event.data;\n\n    // This is the initial connection event\n    if (data === 'connected') {\n      this.connecting = false;\n      this.connected = true;\n\n      this.trigger('connected');\n\n      // Be polite and respond to the child that we're ready\n      if (!this.isChild) {\n        this.target.postMessage(data, this.origin);\n      }\n\n      const len = this._sendLater.length;\n\n      // If we have any sends waiting to send\n      // we are now connected and it should be okay\n      if (len > 0) {\n        for (let i = 0; i < len; i++) {\n          const e = this._sendLater[i];\n          this.send(e.data);\n        }\n        this._sendLater.length = 0;\n      }\n    } else {\n      // Ignore all other event if we don't have a context\n      if (!this.connected) {\n        return;\n      }\n\n      // Only valid objects with a type and matching channel id\n      if (typeof data === 'object' && data.type) {\n        this.trigger(data);\n      }\n    }\n  }\n\n  /**\n   *  Setup the connection\n   *  @method connect\n   *  @param {HTMLIFrameElement}  [iframe] The iframe to communicate with. If no value is set, the assumption\n   *         is that we're the child trying to communcate with our window.parent\n   *  @param {String} [origin=\"*\"] The domain to communicate with if different from the current.\n   *  @return {Bellhop} Return instance of current object\n   */\n  connect(iframe, origin = '*') {\n    // Ignore if we're already trying to connect\n    if (this.connecting) {\n      return;\n    }\n\n    // Disconnect from any existing connection\n    this.disconnect();\n\n    // We are trying to connect\n    this.connecting = true;\n\n    //re-init if we had previously been destroyed\n    if (!this._sendLater) {\n      this._sendLater = [];\n    }\n\n    // The iframe if we're the parent\n    this.iframe = iframe || null;\n\n    // The instance of bellhop is inside the iframe\n    this.isChild = iframe !== undefined;\n\n    this.supported = this.isChild\n      ? !!this.target && window != this.target\n      : !!this.target;\n    this.origin = origin;\n\n    window.addEventListener('message', this.receive);\n    if (this.isChild) {\n      // No parent, can't connect\n      if (window === this.target) {\n        this.trigger('failed');\n      } else {\n        window.addEventListener('load', () => {\n          this.target.postMessage('connected', this.origin);\n        });\n      }\n    }\n  }\n\n  /**\n   *  Disconnect if there are any open connections\n   *  @method disconnect\n   */\n  disconnect() {\n    this.connected = false;\n    this.connecting = false;\n    this.origin = null;\n    this.iframe = null;\n    this.isChild = true;\n\n    if (this._sendLater) {\n      this._sendLater.length = 0;\n    }\n\n    window.removeEventListener('message', this.receive);\n  }\n\n  /**\n   *  Send an event to the connected instance\n   *  @method send\n   *  @param {*} [data] Additional data to send along with event\n   *  @return {Bellhop} Return instance of current object\n   */\n  send(data) {\n    if (this.connecting) {\n      this._sendLater.push(data);\n    } else if (!this.connected) {\n      return;\n    } else {\n      this.target.postMessage(data, this.origin);\n    }\n  }\n\n  /**\n   *  A convenience method for sending and the listening to create\n   *  a singular link to fetching data. This is the same calling send\n   *  and then getting a response right away with the same event.\n   *  @method fetch\n   *  @param {String} event The name of the event\n   *  @param {Function} callback The callback to call after, takes event object as one argument\n   *  @param {Object} [data] Optional data to pass along\n   *  @param {Boolean} [runOnce=false] If we only want to fetch once and then remove the listener\n   */\n  fetch(event, callback, data, runOnce) {\n    if (!this.connecting && !this.connected) {\n      throw 'No connection, please call connect() first';\n    }\n\n    runOnce = runOnce === undefined ? false : runOnce;\n    const internalCallback = e => {\n      if (runOnce) {\n        this.off(e.type, internalCallback);\n      }\n\n      callback(e);\n    };\n\n    this.on(event, internalCallback);\n\n    this.send(data);\n  }\n\n  /**\n   *  A convience method for listening to an event and then responding with some data\n   *  right away. Automatically removes the listener\n   *  @method respond\n   *  @param {String} event The name of the event\n   *  @param {Object} data The object to pass back.\n   *  \tMay also be a function; the return value will be sent as data in this case.\n   *  @param {Boolean} [runOnce=false] If we only want to respond once and then remove the listener\n   */\n  respond(event, data, runOnce) {\n    runOnce = runOnce === undefined ? false : runOnce;\n\n    const internalCallback = e => {\n      if (runOnce) {\n        this.off(e.type, internalCallback);\n      }\n\n      this.send(data);\n    };\n\n    this.on(event, internalCallback);\n  }\n\n  /**\n   *  Destroy and don't user after this\n   *  @method destroy\n   */\n  destroy() {\n    super.destroy();\n    this.disconnect();\n    this._sendLater = null;\n  }\n}\n"],"names":["BellhopEventDispatcher","_listeners","type","callback","priority","t","on","types","split","listener","i","len","length","this","_priority","parseInt","indexOf","push","sort","listenerSorter","a","b","undefined","listeners","splice","event","Bellhop","connected","name","isChild","connecting","origin","_sendLater","supported","iframe","target","_this","window","parent","contentWindow","source","data","trigger","postMessage","e","send","disconnect","addEventListener","receive","_this2","removeEventListener","runOnce","internalCallback","off"],"mappings":"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"}
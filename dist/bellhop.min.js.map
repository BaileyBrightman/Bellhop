{"version":3,"file":"bellhop.min.js","sources":["../src/BellhopEventDispatcher.js","../src/Bellhop.js"],"sourcesContent":["/**\n * Generic event dispatcher\n * @class  BellhopEventDispatcher\n */\nexport default class BellhopEventDispatcher {\n  /**\n   *  The collection of event listeners\n   *  @property {Object} _listeners\n   *  @private\n   */\n  constructor() {\n    this._listeners = {};\n  }\n\n  /**\n   *  Add an event listener to the listen to an event from either the parent or iframe\n   *  @method on\n   *  @param {String|Object} eventType The type of event to listen for or a map of events to callbacks.\n   *         Multiple events can be added by separating events with spaces.\n   *  @param {Function} callback The handler when an event is triggered\n   *  @param {number} [priority=0] The priority of the event listener. Higher numbers are handled first.\n   */\n  on(eventType, callback, priority) {\n    if ('string' !== typeof eventType) {\n      for (let type in eventType) {\n        this.on(type, eventType[type], priority);\n      }\n    } else {\n      const types = eventType.split(' ');\n      for (let i = 0, l = types.length; i < l; i++) {\n        const type = types[i];\n\n        if (!this._listeners[type]) {\n          this._listeners[type] = [];\n        }\n        callback._priority = parseInt(priority) || 0;\n\n        if (this._listeners[type].indexOf(callback) === -1) {\n          this._listeners[type].push(callback);\n          if (this._listeners[type].length > 1) {\n            this._listeners[type].sort(this.listenerSorter);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   *  Sorts listeners added by .on() by priority\n   */\n  listenerSorter(a, b) {\n    return a._priority - b._priority;\n  }\n\n  /**\n   *  Remove an event listener\n   *  @method off\n   *  @param {String} type The type of event to listen for. If undefined, remove all listeners.\n   *  @param {Function} [callback] The optional handler when an event is triggered, if no callback\n   *         is set then all listeners by type are removed\n   */\n  off(type, callback) {\n    if (type === undefined || !this._listeners) {\n      //remove all listeners\n      this._listeners = {};\n      return this;\n    }\n    if (this._listeners[type] === undefined) {\n      return this;\n    }\n    if (callback === undefined) {\n      delete this._listeners[type];\n    } else {\n      for (let i = 0, l = this._listeners[type].length; i < l; i++) {\n        // Remove the listener\n        if (this._listeners[type][i] === callback) {\n          this._listeners[type].splice(i, 1);\n          break;\n        }\n      }\n    }\n  }\n\n  /**\n   *  Trigger any event handlers for an event type\n   *  @method trigger\n   *  @param {Object} event The event to send\n   */\n  trigger(event) {\n    if (typeof event == 'string') {\n      event = {\n        type: event\n      };\n    }\n\n    if (this._listeners[event.type] !== undefined) {\n      for (let i = this._listeners[event.type].length - 1; i >= 0; i--) {\n        this._listeners[event.type][i](event);\n      }\n    }\n  }\n\n  /**\n   * Destroy this object\n   * @method  destroy\n   */\n  destroy() {\n    this._listeners = null;\n  }\n}\n","import BellhopEventDispatcher from './BellhopEventDispatcher.js';\n/**\n *  Abstract the communication layer between the iframe\n *  and the parent DOM\n *  @class Bellhop\n *  @extends BellhopEventDispatcher\n */\nexport default class Bellhop extends BellhopEventDispatcher {\n  /**\n   * Creates an instance of Bellhop.\n   * @memberof Bellhop\n   */\n  constructor() {\n    super();\n\n    /**\n     *  If we are connected to another instance of the bellhop\n     *  @property {Boolean} connected\n     *  @readOnly\n     *  @default false\n     *  @private\n     */\n    this.connected = false;\n\n    /**\n     *  The name of this Bellhop instance, useful for debugging purposes\n     *  @param {String} name\n     */\n    this.name = '';\n\n    /**\n     *  If this instance represents an iframe instance\n     *  @property {Boolean} isChild\n     *  @private\n     *  @default true\n     */\n    this.isChild = true;\n\n    /**\n     *  If we are current trying to connec\n     *  @property {Boolean} connecting\n     *  @default false\n     *  @private\n     */\n    this.connecting = false;\n\n    /**\n     *  If using cross-domain, the domain to post to\n     *  @property {Boolean} origin\n     *  @private\n     *  @default \"*\"\n     */\n    this.origin = '*';\n\n    /**\n     *  Save any sends to wait until after we're done\n     *  @property {Array} _sendLater\n     *  @private\n     */\n    this._sendLater = [];\n\n    /**\n     * The iframe element\n     * @property {DOMElement} iframe\n     * @private\n     * @readOnly\n     */\n    this.iframe = null;\n  }\n\n  /**\n   *  The connection has been established successfully\n   *  @event connected\n   */\n\n  /**\n   *  Connection could not be established\n   *  @event failed\n   */\n\n  /**\n   *  Handle messages in the window\n   *  @method receive\n   *  @private\n   */\n  receive(event) {\n    console.log(event);\n    // Ignore events that don't originate from the target\n    // we're connected to\n    if (this.getTarget !== event.source) {\n      return;\n    }\n\n    console.log('did make it passed');\n\n    const data = event.data;\n\n    // This is the initial connection event\n    if (data === 'connected') {\n      this.connecting = false;\n      this.connected = true;\n\n      this.trigger('connected');\n\n      // Be polite and respond to the child that we're ready\n      if (!this.isChild) {\n        this.getTarget.postMessage(data, this.origin);\n      }\n\n      const len = this._sendLater.length;\n\n      // If we have any sends waiting to send\n      // we are now connected and it should be okay\n      if (len > 0) {\n        for (let i = 0; i < len; i++) {\n          const e = this._sendLater[i];\n          this.send(e.data);\n        }\n        this._sendLater.length = 0;\n      }\n    } else {\n      // Ignore all other event if we don't have a context\n      if (!this.connected) {\n        return;\n      }\n\n      // Only valid objects with a type and matching channel id\n      if ('object' === typeof data && data.type) {\n        this.trigger(data);\n      }\n    }\n  }\n\n  /**\n   *  Setup the connection\n   *  @method connect\n   *  @param {HTMLIFrameElement}  [iframe] The iframe to communicate with. If no value is set, the assumption\n   *         is that we're the child trying to communcate with our window.parent\n   *  @param {String} [origin=\"*\"] The domain to communicate with if different from the current.\n   *  @return {Bellhop} Return instance of current object\n   */\n  connect(iframe, origin = '*') {\n    // Ignore if we're already trying to connect\n    if (this.connecting) {\n      return;\n    }\n\n    // Disconnect from any existing connection\n    this.disconnect();\n\n    // We are trying to connect\n    this.connecting = true;\n\n    //re-init if we had previously been destroyed\n    if (!this._sendLater) {\n      this._sendLater = [];\n    }\n\n    // The iframe if we're the parent\n    this.iframe = iframe || null;\n\n    // The instance of bellhop is inside the iframe\n    this.isChild = iframe === undefined;\n\n    this.origin = origin;\n\n    window.addEventListener('message', this.receive.bind(this));\n    if (this.isChild) {\n      // No parent, can't connect\n      if (window === this.getTarget) {\n        this.trigger('failed');\n      } else {\n        this.getTarget.postMessage('connected', this.origin);\n      }\n    }\n  }\n\n  /**\n   *  Disconnect if there are any open connections\n   *  @method disconnect\n   */\n  disconnect() {\n    this.connected = false;\n    this.connecting = false;\n    this.origin = null;\n    this.iframe = null;\n    this.isChild = true;\n\n    if (this._sendLater) {\n      this._sendLater.length = 0;\n    }\n\n    window.removeEventListener('message', this.receive);\n  }\n\n  /**\n   *  Send an event to the connected instance\n   *  @method send\n   *  @param {*} [data] Additional data to send along with event\n   *  @return {Bellhop} Return instance of current object\n   */\n  send(data) {\n    if (this.connecting) {\n      this._sendLater.push(data);\n    } else if (!this.connected) {\n      return;\n    } else {\n      this.getTarget.postMessage(data, this.origin);\n    }\n  }\n\n  /**\n   *  A convenience method for sending and the listening to create\n   *  a singular link to fetching data. This is the same calling send\n   *  and then getting a response right away with the same event.\n   *  @method fetch\n   *  @param {String} event The name of the event\n   *  @param {Function} callback The callback to call after, takes event object as one argument\n   *  @param {Object} [data] Optional data to pass along\n   *  @param {Boolean} [runOnce=false] If we only want to fetch once and then remove the listener\n   */\n  fetch(event, callback, data, runOnce) {\n    if (!this.connecting && !this.connected) {\n      throw 'No connection, please call connect() first';\n    }\n\n    runOnce = runOnce === undefined ? false : runOnce;\n    const internalCallback = e => {\n      if (runOnce) {\n        this.off(e.type, internalCallback);\n      }\n\n      callback(e);\n    };\n\n    this.on(event, internalCallback);\n\n    this.send(data);\n  }\n\n  /**\n   *  A convience method for listening to an event and then responding with some data\n   *  right away. Automatically removes the listener\n   *  @method respond\n   *  @param {String} event The name of the event\n   *  @param {Object} data The object to pass back.\n   *  \tMay also be a function; the return value will be sent as data in this case.\n   *  @param {Boolean} [runOnce=false] If we only want to respond once and then remove the listener\n   */\n  respond(event, data, runOnce = false) {\n    const internalCallback = e => {\n      if (runOnce) {\n        this.off(e.type, internalCallback);\n      }\n\n      this.send(data);\n    };\n\n    this.on(event, internalCallback);\n  }\n\n  /**\n   *  Destroy and don't user after this\n   *  @method destroy\n   */\n  destroy() {\n    super.destroy();\n    this.disconnect();\n    this._sendLater = null;\n  }\n\n  /**\n   *\n   *\n   * @returns {Window}\n   * @memberof Bellhop\n   */\n  get getTarget() {\n    return this.isChild ? window.parent : this.iframe.contentWindow;\n  }\n}\n"],"names":["BellhopEventDispatcher","_listeners","eventType","callback","priority","type","on","types","split","i","l","length","this","_priority","parseInt","indexOf","push","sort","listenerSorter","a","b","undefined","splice","event","Bellhop","connected","name","isChild","connecting","origin","_sendLater","iframe","log","getTarget","source","data","trigger","postMessage","len","e","send","disconnect","addEventListener","receive","bind","window","removeEventListener","runOnce","internalCallback","off","parent","contentWindow"],"mappings":"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"}
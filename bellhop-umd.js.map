{"version":3,"file":"bellhop-umd.js","sources":["src/BellhopEventDispatcher.js","src/Bellhop.js"],"sourcesContent":["/**\n * Function with a added priority type\n * @typedef {Function} PriorityFunction\n * @property {number} _priority\n */\n\n/**\n * Generic event dispatcher\n * @class  BellhopEventDispatcher\n */\nexport class BellhopEventDispatcher {\n  /**\n   *  The collection of event listeners\n   *  @property {Object} _listeners\n   *  @private\n   */\n  constructor() {\n    this._listeners = {};\n  }\n\n  /**\n   *  Add an event listener to the listen to an event from either the parent or iframe\n   *  @method on\n   *  @param {String} name The name of the event to listen\n   *  @param {PriorityFunction} callback The handler when an event is triggered\n   *  @param {number} [priority=0] The priority of the event listener. Higher numbers are handled first.\n   */\n  on(name, callback, priority = 0) {\n    if (!this._listeners[name]) {\n      this._listeners[name] = [];\n    }\n    callback._priority = parseInt(priority) || 0;\n\n    // If callback is already set to this event\n    if (-1 !== this._listeners[name].indexOf(callback)) {\n      return;\n    }\n\n    this._listeners[name].push(callback);\n\n    if (this._listeners[name].length > 1) {\n      this._listeners[name].sort(this.listenerSorter);\n    }\n  }\n\n  /**\n   * @private\n   * @param {PriorityFunction} a\n   * @param {PriorityFunction} b\n   * @returns {number};\n   *  Sorts listeners added by .on() by priority\n   */\n  listenerSorter(a, b) {\n    return a._priority - b._priority;\n  }\n\n  /**\n   *  Remove an event listener\n   *  @method off\n   *  @param {String} name The name of event to listen for. If undefined, remove all listeners.\n   *  @param {Function} callback The optional handler when an event is triggered, if no callback\n   *         is set then all listeners by type are removed\n   */\n  off(name, callback) {\n    if (this._listeners[name] === undefined) {\n      return;\n    }\n\n    if (callback === undefined) {\n      delete this._listeners[name];\n      return;\n    }\n\n    const index = this._listeners[name].indexOf(callback);\n\n    -1 < index ? this._listeners[name].splice(index, 1) : undefined;\n  }\n\n  /**\n   *  Trigger any event handlers for an event type\n   *  @method trigger\n   *  @param {Object | String} event The event to send\n   */\n  trigger(event) {\n    if (typeof event == 'string') {\n      event = {\n        type: event\n      };\n    }\n\n    if ('undefined' !== typeof this._listeners[event.type]) {\n      for (let i = this._listeners[event.type].length - 1; i >= 0; i--) {\n        this._listeners[event.type][i](event);\n      }\n    }\n  }\n\n  /**\n   * Reset the listeners object\n   * @method  destroy\n   */\n  destroy() {\n    this._listeners = {};\n  }\n}\n","import { BellhopEventDispatcher } from './BellhopEventDispatcher.js';\n\n/**\n *  Abstract the communication layer between the iframe\n *  and the parent DOM\n *  @class Bellhop\n *  @extends BellhopEventDispatcher\n */\nexport class Bellhop extends BellhopEventDispatcher {\n  /**\n   * Creates an instance of Bellhop.\n   * @memberof Bellhop\n   * @param { string | number } id the id of the Bellhop instance\n   */\n  constructor(id = (Math.random() * 100) | 0) {\n    super();\n\n    /**\n     *  The instance ID for bellhop\n     *  @property {string} id\n     */\n    this.id = `BELLHOP:${id}`;\n    /**\n     *  If we are connected to another instance of the bellhop\n     *  @property {Boolean} connected\n     *  @readOnly\n     *  @default false\n     *  @private\n     */\n    this.connected = false;\n\n    /**\n     *  If this instance represents an iframe instance\n     *  @property {Boolean} isChild\n     *  @private\n     *  @default true\n     */\n    this.isChild = true;\n\n    /**\n     *  If we are current trying to connec\n     *  @property {Boolean} connecting\n     *  @default false\n     *  @private\n     */\n    this.connecting = false;\n\n    /**\n     *  If using cross-domain, the domain to post to\n     *  @property {string} origin\n     *  @private\n     *  @default \"*\"\n     */\n    this.origin = '*';\n\n    /**\n     *  Save any sends to wait until after we're done\n     *  @property {Array} _sendLater\n     *  @private\n     */\n    this._sendLater = [];\n\n    /**\n     * The iframe element\n     * @property {HTMLIFrameElement} iframe\n     * @private\n     * @readOnly\n     */\n    this.iframe = null;\n  }\n\n  /**\n   *  The connection has been established successfully\n   *  @event connected\n   */\n\n  /**\n   *  Connection could not be established\n   *  @event failed\n   */\n\n  /**\n   *  Handle messages in the window\n   *  @method receive\n   *  @param { MessageEvent } message the post message received from another bellhop instance\n   *  @private\n   */\n  receive(message) {\n    // Ignore messages that don't originate from the target\n    // we're connected to\n    if (this.target !== message.source) {\n      return;\n    }\n\n    // If this is not the initial connection message\n    if (message.data !== 'connected') {\n      // Ignore all other message if we don't have a context\n      if (\n        this.connected &&\n        'object' === typeof message.data &&\n        message.data.type\n      ) {\n        this.trigger(message.data);\n      }\n      return;\n    }\n    // Else setup the connection\n    this.onConnectionReceived(message.data);\n  }\n  /**\n   * @memberof Bellhop\n   * @param {object} message the message received from the other bellhop instance\n   * @private\n   */\n  onConnectionReceived(message) {\n    this.connecting = false;\n    this.connected = true;\n\n    // If there is a connection event assigned call it\n    this.trigger('connected');\n\n    // Be polite and respond to the child that we're ready\n    if (!this.isChild) {\n      this.target.postMessage(message, this.origin);\n    }\n\n    // If we have any sends waiting to send\n    // we are now connected and it should be okay\n    for (let i = 0, length = this._sendLater.length; i < length; i++) {\n      const { type, data } = this._sendLater[i];\n      this.send(type, data);\n    }\n    this._sendLater.length = 0;\n  }\n\n  /**\n   *  Setup the connection\n   *  @method connect\n   *  @param {HTMLIFrameElement} iframe The iframe to communicate with. If no value is set, the assumption\n   *         is that we're the child trying to communcate with our window.parent\n   *  @param {String} [origin=\"*\"] The domain to communicate with if different from the current.\n   *  @return {Bellhop} Return instance of current object\n   */\n  connect(iframe, origin = '*') {\n    // Ignore if we're already trying to connect\n    if (this.connecting) {\n      return;\n    }\n\n    // Disconnect from any existing connection\n    this.disconnect();\n\n    // We are trying to connect\n    this.connecting = true;\n\n    // The iframe if we're the parent\n    if (iframe instanceof HTMLIFrameElement) {\n      this.iframe = iframe;\n    }\n\n    // The instance of bellhop is inside the iframe\n    this.isChild = iframe === undefined;\n  \n    this.supported = true;\n    if(this.isChild) {\n      // for child pages, the window passed must be a different window\n      this.supported = window != iframe;\n    }\n\n    this.origin = origin;\n\n    window.addEventListener('message', this.receive.bind(this));\n\n    if (this.isChild) {\n      // No parent, can't connect\n      if (window === this.target) {\n        this.trigger('failed');\n      } else {\n        // If connect is called after the window is ready\n        // we can go ahead and send the connect message\n        this.target.postMessage('connected', this.origin);\n      }\n    }\n  }\n\n  /**\n   *  Disconnect if there are any open connections\n   *  @method disconnect\n   */\n  disconnect() {\n    this.connected = false;\n    this.connecting = false;\n    this.origin = null;\n    this.iframe = null;\n    this.isChild = true;\n    this._sendLater.length = 0;\n\n    window.removeEventListener('message', this.receive);\n  }\n\n  /**\n   *  Send an event to the connected instance\n   *  @method send\n   *  @param {string} type name/type of the event\n   *  @param {*} [data = {}] Additional data to send along with event\n   */\n  send(type, data = {}) {\n    if (typeof type !== 'string') {\n      throw 'The event type must be a string';\n    }\n\n    const message = {\n      type,\n      data\n    };\n\n    if (this.connecting) {\n      this._sendLater.push(message);\n    } else {\n      this.target.postMessage(message, this.origin);\n    }\n  }\n\n  /**\n   *  A convenience method for sending and the listening to create\n   *  a singular link to fetching data. This is the same calling send\n   *  and then getting a response right away with the same event.\n   *  @method fetch\n   *  @param {String} event The name of the event\n   *  @param {Function} callback The callback to call after, takes event object as one argument\n   *  @param {Object} [data = {}] Optional data to pass along\n   *  @param {Boolean} [runOnce=false] If we only want to fetch once and then remove the listener\n   */\n  fetch(event, callback, data = {}, runOnce = false) {\n    if (!this.connecting && !this.connected) {\n      throw 'No connection, please call connect() first';\n    }\n\n    const internalCallback = e => {\n      if (runOnce) {\n        this.off(e.type, internalCallback);\n      }\n\n      callback(e);\n    };\n\n    this.on(event, internalCallback);\n    this.send(event, data);\n  }\n\n  /**\n   *  A convience method for listening to an event and then responding with some data\n   *  right away. Automatically removes the listener\n   *  @method respond\n   *  @param {String} event The name of the event\n   *  @param {Object} [data = {}] The object to pass back.\n   *  \tMay also be a function; the return value will be sent as data in this case.\n   *  @param {Boolean} [runOnce=false] If we only want to respond once and then remove the listener\n   */\n  respond(event, data = {}, runOnce = false) {\n    const internalCallback = e => {\n      if (runOnce) {\n        this.off(e.type, internalCallback);\n      }\n      this.send(event, data);\n    };\n    this.on(event, internalCallback);\n  }\n\n  /**\n   *  Destroy and don't user after this\n   *  @method destroy\n   */\n  destroy() {\n    super.destroy();\n    this.disconnect();\n    this._sendLater.length = 0;\n  }\n\n  /**\n   *\n   * Returns the correct parent element for Bellhop's context\n   * @readonly\n   * @memberof Bellhop\n   */\n  get target() {\n    return this.isChild ? window.parent : this.iframe.contentWindow;\n  }\n}\n"],"names":["BellhopEventDispatcher","_listeners","name","callback","priority","this","_priority","parseInt","indexOf","push","length","sort","listenerSorter","a","b","undefined","index","splice","event","type","i","Bellhop","id","Math","random","connected","isChild","connecting","origin","_sendLater","iframe","message","target","source","data","onConnectionReceived","trigger","postMessage","send","disconnect","HTMLIFrameElement","supported","window","addEventListener","receive","bind","removeEventListener","runOnce","on","internalCallback","off","e","parent","contentWindow"],"mappings":"24BAUaA,yCAOJC,mDAUJC,EAAMC,OAAUC,yDAAW,EACvBC,KAAKJ,WAAWC,UACdD,WAAWC,SAETI,UAAYC,SAASH,IAAa,GAGtC,IAAMC,KAAKJ,WAAWC,GAAMM,QAAQL,UAIpCF,WAAWC,GAAMO,KAAKN,GAEvBE,KAAKJ,WAAWC,GAAMQ,OAAS,QAC5BT,WAAWC,GAAMS,KAAKN,KAAKO,wDAWrBC,EAAGC,UACTD,EAAEP,UAAYQ,EAAER,sCAUrBJ,EAAMC,WACsBY,IAA1BV,KAAKJ,WAAWC,WAIHa,IAAbZ,OAKEa,EAAQX,KAAKJ,WAAWC,GAAMM,QAAQL,IAE3C,EAAIa,GAAQX,KAAKJ,WAAWC,GAAMe,OAAOD,EAAO,eANxCX,KAAKJ,WAAWC,mCAcnBgB,MACc,iBAATA,YAEDA,SAIN,IAAuBb,KAAKJ,WAAWiB,EAAMC,UAC1C,IAAIC,EAAIf,KAAKJ,WAAWiB,EAAMC,MAAMT,OAAS,EAAGU,GAAK,EAAGA,SACtDnB,WAAWiB,EAAMC,MAAMC,GAAGF,0CAU9BjB,uBC9FIoB,+BAMCC,yDAAsB,IAAhBC,KAAKC,SAAkB,sFAOlCF,cAAgBA,IAQhBG,WAAY,IAQZC,SAAU,IAQVC,YAAa,IAQbC,OAAS,MAOTC,gBAQAC,OAAS,0UA5DW9B,sCA+EnB+B,GAGF1B,KAAK2B,SAAWD,EAAQE,SAKP,cAAjBF,EAAQG,UAYPC,qBAAqBJ,EAAQG,MAT9B7B,KAAKoB,WACL,aAAoBM,EAAQG,OAC5BH,EAAQG,KAAKf,WAERiB,QAAQL,EAAQG,oDAYNH,QACdJ,YAAa,OACbF,WAAY,OAGZW,QAAQ,aAGR/B,KAAKqB,cACHM,OAAOK,YAAYN,EAAS1B,KAAKuB,YAKnC,IAAIR,EAAI,EAAGV,EAASL,KAAKwB,WAAWnB,OAAQU,EAAIV,EAAQU,IAAK,OACzCf,KAAKwB,WAAWT,GAA/BD,IAAAA,KAAMe,IAAAA,UACTI,KAAKnB,EAAMe,QAEbL,WAAWnB,OAAS,kCAWnBoB,OAAQF,yDAAS,IAEnBvB,KAAKsB,kBAKJY,kBAGAZ,YAAa,EAGdG,aAAkBU,yBACfV,OAASA,QAIXJ,aAAqBX,IAAXe,OAEVW,WAAY,EACdpC,KAAKqB,eAEDe,UAAYC,QAAUZ,QAGxBF,OAASA,SAEPe,iBAAiB,UAAWtC,KAAKuC,QAAQC,KAAKxC,OAEjDA,KAAKqB,UAEHgB,SAAWrC,KAAK2B,YACbI,QAAQ,eAIRJ,OAAOK,YAAY,YAAahC,KAAKuB,oDAUzCH,WAAY,OACZE,YAAa,OACbC,OAAS,UACTE,OAAS,UACTJ,SAAU,OACVG,WAAWnB,OAAS,SAElBoC,oBAAoB,UAAWzC,KAAKuC,sCASxCzB,OAAMe,+DACW,iBAATf,OACH,sCAGFY,kBAKF1B,KAAKsB,gBACFE,WAAWpB,KAAKsB,QAEhBC,OAAOK,YAAYN,EAAS1B,KAAKuB,sCAcpCV,EAAOf,cAAU+B,4DAAWa,8DAC3B1C,KAAKsB,aAAetB,KAAKoB,eACtB,kDAWHuB,GAAG9B,EARiB,SAAnB+B,KACAF,KACGG,IAAIC,EAAEhC,KAAM8B,KAGVE,UAINb,KAAKpB,EAAOgB,mCAYXhB,cAAOgB,4DAAWa,+DAOnBC,GAAG9B,EANiB,SAAnB+B,KACAF,KACGG,IAAIC,EAAEhC,KAAM8B,KAEdX,KAAKpB,EAAOgB,6XAWdK,kBACAV,WAAWnB,OAAS,wCAUlBL,KAAKqB,QAAUgB,OAAOU,OAAS/C,KAAKyB,OAAOuB"}
{"version":3,"file":"bellhop-umd.js","sources":["src/BellhopEventDispatcher.js","src/Bellhop.js"],"sourcesContent":["/**\r\n * Function with a added priority type\r\n * @typedef {Function} PriorityFunction\r\n * @property {number} _priority\r\n */\r\n\r\n/**\r\n * Generic event dispatcher\r\n * @class  BellhopEventDispatcher\r\n */\r\nexport class BellhopEventDispatcher {\r\n  /**\r\n   *  The collection of event listeners\r\n   *  @property {Object} _listeners\r\n   *  @private\r\n   */\r\n  constructor() {\r\n    this._listeners = {};\r\n  }\r\n\r\n  /**\r\n   *  Add an event listener to the listen to an event from either the parent or iframe\r\n   *  @method on\r\n   *  @param {String} name The name of the event to listen\r\n   *  @param {PriorityFunction} callback The handler when an event is triggered\r\n   *  @param {number} [priority=0] The priority of the event listener. Higher numbers are handled first.\r\n   */\r\n  on(name, callback, priority = 0) {\r\n    if (!this._listeners[name]) {\r\n      this._listeners[name] = [];\r\n    }\r\n    callback._priority = parseInt(priority) || 0;\r\n\r\n    // If callback is already set to this event\r\n    if (-1 !== this._listeners[name].indexOf(callback)) {\r\n      return;\r\n    }\r\n\r\n    this._listeners[name].push(callback);\r\n\r\n    if (this._listeners[name].length > 1) {\r\n      this._listeners[name].sort(this.listenerSorter);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {PriorityFunction} a\r\n   * @param {PriorityFunction} b\r\n   * @returns {number};\r\n   *  Sorts listeners added by .on() by priority\r\n   */\r\n  listenerSorter(a, b) {\r\n    return a._priority - b._priority;\r\n  }\r\n\r\n  /**\r\n   *  Remove an event listener\r\n   *  @method off\r\n   *  @param {String} name The name of event to listen for. If undefined, remove all listeners.\r\n   *  @param {Function} [callback] The optional handler when an event is triggered, if no callback\r\n   *         is set then all listeners by type are removed\r\n   */\r\n  off(name, callback) {\r\n    if (this._listeners[name] === undefined) {\r\n      return;\r\n    }\r\n\r\n    if (callback === undefined) {\r\n      delete this._listeners[name];\r\n      return;\r\n    }\r\n\r\n    const index = this._listeners[name].indexOf(callback);\r\n\r\n    -1 < index ? this._listeners[name].splice(index, 1) : undefined;\r\n  }\r\n\r\n  /**\r\n   *  Trigger any event handlers for an event type\r\n   *  @method trigger\r\n   *  @param {object | String} event The event to send\r\n   *  @param {object} [data = {}] optional data to send to other areas in the app that are listening for this event\r\n   */\r\n  trigger(event, data = {}) {\r\n    if (typeof event == 'string') {\r\n      event = {\r\n        type: event,\r\n        data: 'object' === typeof data && null !== data ? data : {}\r\n      };\r\n    }\r\n\r\n    if ('undefined' !== typeof this._listeners[event.type]) {\r\n      for (let i = this._listeners[event.type].length - 1; i >= 0; i--) {\r\n        this._listeners[event.type][i](event);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reset the listeners object\r\n   * @method  destroy\r\n   */\r\n  destroy() {\r\n    this._listeners = {};\r\n  }\r\n}\r\n","import { BellhopEventDispatcher } from './BellhopEventDispatcher.js';\r\n\r\n/**\r\n *  Abstract the communication layer between the iframe\r\n *  and the parent DOM\r\n *  @class Bellhop\r\n *  @extends BellhopEventDispatcher\r\n */\r\nexport class Bellhop extends BellhopEventDispatcher {\r\n  /**\r\n   * Creates an instance of Bellhop.\r\n   * @memberof Bellhop\r\n   * @param { string | number } id the id of the Bellhop instance\r\n   */\r\n  constructor(id = (Math.random() * 100) | 0) {\r\n    super();\r\n\r\n    /**\r\n     *  The instance ID for bellhop\r\n     *  @property {string} id\r\n     */\r\n    this.id = `BELLHOP:${id}`;\r\n    /**\r\n     *  If we are connected to another instance of the bellhop\r\n     *  @property {Boolean} connected\r\n     *  @readOnly\r\n     *  @default false\r\n     *  @private\r\n     */\r\n    this.connected = false;\r\n\r\n    /**\r\n     *  If this instance represents an iframe instance\r\n     *  @property {Boolean} isChild\r\n     *  @private\r\n     *  @default true\r\n     */\r\n    this.isChild = true;\r\n\r\n    /**\r\n     *  If we are current trying to connec\r\n     *  @property {Boolean} connecting\r\n     *  @default false\r\n     *  @private\r\n     */\r\n    this.connecting = false;\r\n\r\n    /**\r\n     *  If using cross-domain, the domain to post to\r\n     *  @property {string} origin\r\n     *  @private\r\n     *  @default \"*\"\r\n     */\r\n    this.origin = '*';\r\n\r\n    /**\r\n     *  Save any sends to wait until after we're done\r\n     *  @property {Array} _sendLater\r\n     *  @private\r\n     */\r\n    this._sendLater = [];\r\n\r\n    /**\r\n     * The iframe element\r\n     * @property {HTMLIFrameElement} iframe\r\n     * @private\r\n     * @readOnly\r\n     */\r\n    this.iframe = null;\r\n  }\r\n\r\n  /**\r\n   *  The connection has been established successfully\r\n   *  @event connected\r\n   */\r\n\r\n  /**\r\n   *  Connection could not be established\r\n   *  @event failed\r\n   */\r\n\r\n  /**\r\n   *  Handle messages in the window\r\n   *  @method receive\r\n   *  @param { MessageEvent } message the post message received from another bellhop instance\r\n   *  @private\r\n   */\r\n  receive(message) {\r\n    // Ignore messages that don't originate from the target\r\n    // we're connected to\r\n    if (this.target !== message.source) {\r\n      return;\r\n    }\r\n\r\n    // If this is not the initial connection message\r\n    if (message.data !== 'connected') {\r\n      let data = message.data;\r\n      // Check to see if the data was sent as a stringified json\r\n      if ('string' === typeof data) {\r\n        try {\r\n          data = JSON.parse(data);\r\n        } catch (err) {\r\n          console.error('Bellhop error: ', err);\r\n        }\r\n      }\r\n      if (this.connected && 'object' === typeof data && data.type) {\r\n        this.trigger(data);\r\n      }\r\n      return;\r\n    }\r\n    // Else setup the connection\r\n    this.onConnectionReceived(message.data);\r\n  }\r\n  /**\r\n   * @memberof Bellhop\r\n   * @param {object} message the message received from the other bellhop instance\r\n   * @private\r\n   */\r\n  onConnectionReceived(message) {\r\n    this.connecting = false;\r\n    this.connected = true;\r\n\r\n    // If there is a connection event assigned call it\r\n    this.trigger('connected');\r\n\r\n    // Be polite and respond to the child that we're ready\r\n    if (!this.isChild) {\r\n      this.target.postMessage(message, this.origin);\r\n    }\r\n\r\n    // If we have any sends waiting to send\r\n    // we are now connected and it should be okay\r\n    for (let i = 0, length = this._sendLater.length; i < length; i++) {\r\n      const { type, data } = this._sendLater[i];\r\n      this.send(type, data);\r\n    }\r\n    this._sendLater.length = 0;\r\n  }\r\n\r\n  /**\r\n   *  Setup the connection\r\n   *  @method connect\r\n   *  @param {HTMLIFrameElement} iframe The iframe to communicate with. If no value is set, the assumption\r\n   *         is that we're the child trying to communcate with our window.parent\r\n   *  @param {String} [origin=\"*\"] The domain to communicate with if different from the current.\r\n   *  @return {Bellhop} Return instance of current object\r\n   */\r\n  connect(iframe, origin = '*') {\r\n    // Ignore if we're already trying to connect\r\n    if (this.connecting) {\r\n      return;\r\n    }\r\n\r\n    // Disconnect from any existing connection\r\n    this.disconnect();\r\n\r\n    // We are trying to connect\r\n    this.connecting = true;\r\n\r\n    // The iframe if we're the parent\r\n    if (iframe instanceof HTMLIFrameElement) {\r\n      this.iframe = iframe;\r\n    }\r\n\r\n    // The instance of bellhop is inside the iframe\r\n    this.isChild = iframe === undefined;\r\n\r\n    this.supported = true;\r\n    if (this.isChild) {\r\n      // for child pages, the window passed must be a different window\r\n      this.supported = window != iframe;\r\n    }\r\n\r\n    this.origin = origin;\r\n\r\n    window.addEventListener('message', this.receive.bind(this));\r\n\r\n    if (this.isChild) {\r\n      // No parent, can't connect\r\n      if (window === this.target) {\r\n        this.trigger('failed');\r\n      } else {\r\n        // If connect is called after the window is ready\r\n        // we can go ahead and send the connect message\r\n        this.target.postMessage('connected', this.origin);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   *  Disconnect if there are any open connections\r\n   *  @method disconnect\r\n   */\r\n  disconnect() {\r\n    this.connected = false;\r\n    this.connecting = false;\r\n    this.origin = null;\r\n    this.iframe = null;\r\n    this.isChild = true;\r\n    this._sendLater.length = 0;\r\n\r\n    window.removeEventListener('message', this.receive);\r\n  }\r\n\r\n  /**\r\n   *  Send an event to the connected instance\r\n   *  @method send\r\n   *  @param {string} type name/type of the event\r\n   *  @param {*} [data = {}] Additional data to send along with event\r\n   */\r\n  send(type, data = {}) {\r\n    if (typeof type !== 'string') {\r\n      throw 'The event type must be a string';\r\n    }\r\n\r\n    const message = {\r\n      type,\r\n      data\r\n    };\r\n\r\n    if (this.connecting) {\r\n      this._sendLater.push(message);\r\n    } else {\r\n      this.target.postMessage(JSON.stringify(message), this.origin);\r\n    }\r\n  }\r\n\r\n  /**\r\n   *  A convenience method for sending and the listening to create\r\n   *  a singular link to fetching data. This is the same calling send\r\n   *  and then getting a response right away with the same event.\r\n   *  @method fetch\r\n   *  @param {String} event The name of the event\r\n   *  @param {Function} callback The callback to call after, takes event object as one argument\r\n   *  @param {Object} [data = {}] Optional data to pass along\r\n   *  @param {Boolean} [runOnce=false] If we only want to fetch once and then remove the listener\r\n   */\r\n  fetch(event, callback, data = {}, runOnce = false) {\r\n    if (!this.connecting && !this.connected) {\r\n      throw 'No connection, please call connect() first';\r\n    }\r\n\r\n    const internalCallback = e => {\r\n      if (runOnce) {\r\n        this.off(e.type, internalCallback);\r\n      }\r\n\r\n      callback(e);\r\n    };\r\n\r\n    this.on(event, internalCallback);\r\n    this.send(event, data);\r\n  }\r\n\r\n  /**\r\n   *  A convience method for listening to an event and then responding with some data\r\n   *  right away. Automatically removes the listener\r\n   *  @method respond\r\n   *  @param {String} event The name of the event\r\n   *  @param {Object} [data = {}] The object to pass back.\r\n   *  \tMay also be a function; the return value will be sent as data in this case.\r\n   *  @param {Boolean} [runOnce=false] If we only want to respond once and then remove the listener\r\n   */\r\n  respond(event, data = {}, runOnce = false) {\r\n    const internalCallback = e => {\r\n      if (runOnce) {\r\n        this.off(e.type, internalCallback);\r\n      }\r\n      this.send(event, data);\r\n    };\r\n    this.on(event, internalCallback);\r\n  }\r\n\r\n  /**\r\n   *  Destroy and don't user after this\r\n   *  @method destroy\r\n   */\r\n  destroy() {\r\n    super.destroy();\r\n    this.disconnect();\r\n    this._sendLater.length = 0;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * Returns the correct parent element for Bellhop's context\r\n   * @readonly\r\n   * @memberof Bellhop\r\n   */\r\n  get target() {\r\n    return this.isChild ? window.parent : this.iframe.contentWindow;\r\n  }\r\n}\r\n"],"names":["BellhopEventDispatcher","_listeners","name","callback","priority","this","_priority","parseInt","indexOf","push","length","sort","listenerSorter","a","b","undefined","index","splice","event","data","type","i","Bellhop","id","Math","random","connected","isChild","connecting","origin","_sendLater","iframe","message","target","source","onConnectionReceived","JSON","parse","err","error","trigger","postMessage","send","disconnect","HTMLIFrameElement","supported","window","addEventListener","receive","bind","removeEventListener","stringify","runOnce","on","internalCallback","off","e","parent","contentWindow"],"mappings":"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"}